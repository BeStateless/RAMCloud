Change RC to check for IBV_QPT_RAW_PACKET (which is provided by Mellanox) rather than IBV_QPT_RAW_ETH (which is not).  As far as I can tell these are the exact same thing.

From: Daniel Noland <daniel@bestateless.com>


---
 src/HaveInfiniband.cc |    4 +--
 src/InfUdDriver.cc    |   40 +++++++++++++++++-----------
 src/Infiniband.cc     |   71 +++++++++++++++++++++++++++++++++++++++++--------
 3 files changed, 86 insertions(+), 29 deletions(-)

diff --git a/src/HaveInfiniband.cc b/src/HaveInfiniband.cc
index 502ba65b..b8c13f05 100644
--- a/src/HaveInfiniband.cc
+++ b/src/HaveInfiniband.cc
@@ -23,8 +23,8 @@
 
 int main() {
     int r;
-    static_assert(IBV_QPT_RAW_ETH >= 0,
-            "Symbol `IBV_QPT_RAW_ETH` is undefined; consider upgrading "
+    static_assert(IBV_QPT_RAW_PACKET >= 0,
+            "Symbol `IBV_QPT_RAW_PACKET` is undefined; consider upgrading "
             "your libverbs.");
     ibv_free_device_list(ibv_get_device_list(&r));
     return r;
diff --git a/src/InfUdDriver.cc b/src/InfUdDriver.cc
index 3fa2e4d3..1daa485e 100644
--- a/src/InfUdDriver.cc
+++ b/src/InfUdDriver.cc
@@ -85,18 +85,17 @@ InfUdDriver::InfUdDriver(Context* context, const ServiceLocator *sl,
     , zeroCopyRegion(NULL)
     , sendsSinceLastReap(0)
 {
+    LOG(NOTICE, "ethernet: %u", static_cast<unsigned int>(ethernet));
     const char *ibDeviceName = NULL;
     bool macAddressProvided = false;
 
     if (sl != NULL) {
         locatorString = sl->getDriverLocatorString();
 
-        if (ethernet) {
-            try {
-                localMac.construct(sl->getOption<const char*>("mac"));
-                macAddressProvided = true;
-            } catch (ServiceLocator::NoSuchKeyException& e) {}
-        }
+        try {
+            localMac.construct(sl->getOption<const char*>("mac"));
+            macAddressProvided = true;
+        } catch (ServiceLocator::NoSuchKeyException& e) {}
 
         try {
             ibDeviceName   = sl->getOption<const char *>("dev");
@@ -109,7 +108,10 @@ InfUdDriver::InfUdDriver(Context* context, const ServiceLocator *sl,
         try {
             bandwidthGbps = sl->getOption<int>("gbs");
         } catch (ServiceLocator::NoSuchKeyException& e) {}
+
     }
+    LOG(NOTICE, "macAddressProvided: %u", static_cast<unsigned int>(macAddressProvided));
+
     queueEstimator.setBandwidth(1000*bandwidthGbps);
     maxTransmitQueueSize = (uint32_t) (static_cast<double>(bandwidthGbps)
             * MAX_DRAIN_TIME / 8.0);
@@ -125,11 +127,17 @@ InfUdDriver::InfUdDriver(Context* context, const ServiceLocator *sl,
     if (ethernet && !macAddressProvided)
         localMac.construct(MacAddress::RANDOM);
 
+    //LOG(NOTICE, "localMac: %s", localMac ? localMac->toString() : "0");
+    LOG(NOTICE, "ibDeviceName: %s", ibDeviceName ? ibDeviceName : "no device name");
+    LOG(NOTICE, "ibPhysicalPort: %d", ibPhysicalPort);
+
     infiniband = realInfiniband.construct(ibDeviceName);
 
+    //LOG(NOTICE, "infiniband: %u", infiniband);
+
     // Allocate buffer pools.
-    uint32_t bufSize = (maxPacketSize +
-        (localMac ? sizeof32(EthernetHeader) : GRH_SIZE));
+    uint32_t bufSize = maxPacketSize + GRH_SIZE + 2 * sizeof32(EthernetHeader) ;
+        /* (localMac ? sizeof32(EthernetHeader) : GRH_SIZE)); */
     bufSize = BitOps::powerOfTwoGreaterOrEqual(bufSize);
     uint64_t start = Cycles::rdtsc();
 
@@ -158,8 +166,7 @@ InfUdDriver::InfUdDriver(Context* context, const ServiceLocator *sl,
         throw DriverException(HERE, errno);
     }
 
-    qp = infiniband->createQueuePair(localMac ? IBV_QPT_RAW_ETH
-                                              : IBV_QPT_UD,
+    qp = infiniband->createQueuePair(IBV_QPT_UD,
                                      ibPhysicalPort, NULL,
                                      txcq, rxcq, MAX_TX_QUEUE_DEPTH,
                                      MAX_RX_QUEUE_DEPTH,
@@ -167,6 +174,7 @@ InfUdDriver::InfUdDriver(Context* context, const ServiceLocator *sl,
 
     // Cache these for easier access.
     lid = infiniband->getLid(ibPhysicalPort);
+    LOG(NOTICE, "lid: %u", lid);
     qpn = qp->getLocalQpNumber();
 
     // Update our locatorString, if one was provided, with the dynamic
@@ -178,10 +186,9 @@ InfUdDriver::InfUdDriver(Context* context, const ServiceLocator *sl,
         }
         if (localMac) {
             if (!macAddressProvided)
-                locatorString += "mac=" + localMac->toString();
-        } else {
-            locatorString += format("lid=%u,qpn=%u", lid, qpn);
+                locatorString += "mac=" + localMac->toString() + ",";
         }
+        locatorString += format("lid=%u,qpn=%u", lid, qpn);
         LOG(NOTICE, "Locator for InfUdDriver: %s", locatorString.c_str());
     }
 
@@ -212,9 +219,10 @@ InfUdDriver::~InfUdDriver()
 uint32_t
 InfUdDriver::getMaxPacketSize()
 {
-    const uint32_t eth = 1500 + 14 - sizeof32(EthernetHeader);
-    const uint32_t inf = 2048 - GRH_SIZE;
-    return localMac ? eth : inf;
+    /* const uint32_t eth = 1500 + 14 - sizeof32(EthernetHeader); */
+    const uint32_t inf = 1024 - GRH_SIZE - 2 * sizeof32(EthernetHeader);
+    return inf;
+    /* return localMac ? eth : inf; */
 }
 
 /**
diff --git a/src/Infiniband.cc b/src/Infiniband.cc
index 93344f75..3b853a2a 100644
--- a/src/Infiniband.cc
+++ b/src/Infiniband.cc
@@ -13,6 +13,11 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <errno.h>
+#include <cstring>
+#include <string>
+
+
 #include "CycleCounter.h"
 #include "Infiniband.h"
 #include "RawMetrics.h"
@@ -520,7 +525,7 @@ Infiniband::QueuePair::QueuePair(Infiniband& infiniband, ibv_qp_type type,
       peerLid(0)
 {
     snprintf(peerName, sizeof(peerName), "?unknown?");
-    if (type != IBV_QPT_RC && type != IBV_QPT_UD && type != IBV_QPT_RAW_ETH)
+    if (type != IBV_QPT_RC && type != IBV_QPT_UD && type != IBV_QPT_RAW_PACKET)
         throw TransportException(HERE, "invalid queue pair type");
 
     ibv_qp_init_attr qpia;
@@ -564,7 +569,7 @@ Infiniband::QueuePair::QueuePair(Infiniband& infiniband, ibv_qp_type type,
         mask |= IBV_QP_QKEY;
         mask |= IBV_QP_PKEY_INDEX;
         break;
-    case IBV_QPT_RAW_ETH:
+    case IBV_QPT_RAW_PACKET:
         break;
     default:
         assert(0);
@@ -626,12 +631,37 @@ Infiniband::QueuePair::plumb(QueuePairTuple *qpt)
     qpa.rq_psn = qpt->getPsn();
     qpa.max_dest_rd_atomic = 1;
     qpa.min_rnr_timer = 12;
-    qpa.ah_attr.is_global = 0;
+    qpa.ah_attr.is_global = 1;
     qpa.ah_attr.dlid = qpt->getLid();
     qpa.ah_attr.sl = 0;
     qpa.ah_attr.src_path_bits = 0;
     qpa.ah_attr.port_num = downCast<uint8_t>(ibPhysicalPort);
 
+    ibv_global_route grh;
+    memset(&grh, 0, sizeof(grh));
+    grh.hop_limit = 1;
+    grh.flow_label = 9;
+    grh.sgid_index = 1;
+    ibv_gid gid;
+    const int rc = ibv_query_gid(infiniband.device.ctxt, qpa.ah_attr.port_num, grh.sgid_index, &gid);
+    if (rc) {
+      const char* errorstr2 = strerror(rc);
+      LOG(ERROR, "failed to query GID index %d of port %d in device %s",
+          grh.sgid_index,
+          qpa.ah_attr.port_num, 
+          ibv_get_device_name(infiniband.device.ctxt->device)
+      );
+      LOG(ERROR, "ibv_query_gid failed with errorstr %s", errorstr2);
+      throw TransportException(HERE, rc);
+    }
+    std::string gid_raw = "";
+    for (int i = 0; i < 16; ++i) {
+      gid_raw += std::to_string(gid.raw[i]);
+    }
+    LOG(ERROR, "gid.raw == %s", gid_raw.c_str());
+    grh.dgid = gid;
+    qpa.ah_attr.grh = grh;
+
     r = ibv_modify_qp(qp, &qpa, IBV_QP_STATE |
                                 IBV_QP_AV |
                                 IBV_QP_PATH_MTU |
@@ -639,8 +669,11 @@ Infiniband::QueuePair::plumb(QueuePairTuple *qpt)
                                 IBV_QP_RQ_PSN |
                                 IBV_QP_MIN_RNR_TIMER |
                                 IBV_QP_MAX_DEST_RD_ATOMIC);
-    if (r) {
+    if (r != 0) {
+        const char* errorstr = strerror(r);
         LOG(ERROR, "failed to transition to RTR state");
+        LOG(ERROR, "ibv_modify_qp failed with rval %d", r);
+        LOG(ERROR, "ibv_modify_qp failed with errorstr %s", errorstr);
         throw TransportException(HERE, r);
     }
 
@@ -683,7 +716,7 @@ void
 Infiniband::QueuePair::activate(const Tub<MacAddress>& localMac)
 {
     ibv_qp_attr qpa;
-    if (type != IBV_QPT_UD && type != IBV_QPT_RAW_ETH)
+    if (type != IBV_QPT_UD && type != IBV_QPT_RAW_PACKET)
         throw TransportException(HERE, "activate() called on wrong qp type");
 
     if (getState() != IBV_QPS_INIT) {
@@ -704,7 +737,7 @@ Infiniband::QueuePair::activate(const Tub<MacAddress>& localMac)
     // now move to RTS state
     qpa.qp_state = IBV_QPS_RTS;
     int flags = IBV_QP_STATE;
-    if (type != IBV_QPT_RAW_ETH) {
+    if (type != IBV_QPT_RAW_PACKET) {
         qpa.sq_psn = initialPsn;
         flags |= IBV_QP_SQ_PSN;
     }
@@ -714,13 +747,29 @@ Infiniband::QueuePair::activate(const Tub<MacAddress>& localMac)
         throw TransportException(HERE, ret);
     }
 
-    if (type == IBV_QPT_RAW_ETH) {
+    if (type == IBV_QPT_UD) {
+        int const index = 1;
         ibv_gid mgid;
-        memset(&mgid, 0, sizeof(mgid));
-        memcpy(&mgid.raw[10], localMac->address, 6);
-        if (ibv_attach_mcast(qp, &mgid, 0)) {
+        auto const gid_query_error_code = ibv_query_gid(ctxt, ibPhysicalPort, index, &mgid);
+        if (gid_query_error_code != 0) {
+          // const char* gid_query_errorstr = strerror(gid_query_error_code);
+          // LOG("ibv_query_gid failed with error code %d", gid_query_error_code);
+          // LOG("ibv_query_gid failed with errorstr %s", gid_query_errorstr);
+          throw TransportException(HERE, gid_query_error_code);
+        }
+        LOG(ERROR, "gid_querry_error_code == %d", gid_query_error_code);
+        std::string mgid_raw = "";
+        for (int i = 0; i < 16; ++i) {
+          mgid_raw += std::to_string(mgid.raw[i]);
+        }
+        LOG(ERROR, "mgid.raw == %s", mgid_raw.c_str());
+        const int rval = ibv_attach_mcast(qp, &mgid, 0);
+        if (rval != 0) {
+            const char* errorstr = strerror(rval);
             LOG(ERROR, "failed to bind to mac address");
-            throw TransportException(HERE, ret);
+            LOG(ERROR, "ibv_attach_mcast failed with rval %d", rval);
+            LOG(ERROR, "ibv_attach_mcast failed with errorstr %s", errorstr);
+            throw TransportException(HERE, rval);
         }
     }
 }
